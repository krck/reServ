Here are the general steps to create a WebSocket-based chat application in C++:

    Establish a TCP connection:
        Create a socket using the socket system call.
        Bind the socket to a specific IP address and port using the bind system call.
        Start listening for incoming connections using the listen system call.
        Accept incoming client connections using the accept system call.

    Perform the WebSocket handshake:
        Receive the initial HTTP handshake request from the client.
        Parse the request to extract important information like the WebSocket key.
        Generate the WebSocket handshake response and send it back to the client.

    Handle WebSocket communication:
        Read WebSocket frames from the client.
        Parse the frames to determine the message type (e.g., text, binary, close).
        Take appropriate action based on the message type.
        Send WebSocket frames to the client.

    Implement the chat functionality:
    - Broadcast: Send a message received from a client to all connected clients.
    - Unicast: Send a message from a client to a specific other client.
    - Multicast: Send a message from a client to a specific group of other clients.
    - Request-Response: Handle a message by performing some action and then sending a response back to the client that sent the message.
    - Pub-Sub (Publish-Subscribe): Allow clients to subscribe to certain topics or channels and send messages to all clients that have subscribed to a channel when a message is published to it.
    - Pings and Pongs: Use special types of control messages to check the connection status between the client and the server.


1. TCP Connection
    - The TCP Connection is a Layer 4 Protocoll - operates on the Transport Layer
    - On opening a TCP Connection there is a SYN-SYN/ACK-ACK package handshake between Server and Client
    - Once opened, the TCP Connection is "duplex" meaning both Server and Client can send and recieve (talk at the same time)

2. HTTP/HTTPS Connection
    - The HTTP Protocol uses a established TCP Connection to send its Requests/Responses
    - HTTP allows communication only in one direction (Client send Request, Server sends Response - or the other way round)
        - This is by design (even tho it seems like losing a Feature when going from "duplex TCP" up the stack to "simplex HTTP")
        - This allows HTTP to be "stateless". HTTP always sends the full header information on every Request, so the Server does not need to keep track
    - After every Request/Respone the HTTP connection is closed again (but the TCP Connection can stay open - "keep alive")

3. WebSocket Connection
    - The WebSocket Protocol also uses a established TCP Connection to send and recieve
    - The WebSocket Connection uses a initial HTTP Request/Response to "upgrade" the HTTP Connection to a WebSocket Connection, between Client and Server
    - Once the Connection is upgraded from HTTP to WebSocket, the communication is "duplex" again. (Duplex TCP + Duplex WebSocket)
        - This makes WebSocket a state-full connection again (upgrade form HTTP state-less)
        - HTTP is like sending a Letter and waiting for the Server to reply to this one Letter
        - WebSocket is like a Phone call with a open line where both sides can talk at will

- Client establishes a "state-full" and "duplex" TCP Connection
- Client uses the "state-less" and "simplex" HTTP Connection on top of the TCP Connection to establish a WebSocket Connection
- Once upgraded, a "state-full" and "duplex" WebSocket connection is open ontop of the TCP Connection between Server and Client


Here is a great Socket Guide:
https://beej.us/guide/bgnet/html/#intro
https://eklitzke.org/blocking-io-nonblocking-io-and-epoll


CLIENT STATES

Old State	    Action	                New State	    Comment
___________________________________________________________________________________________________
---	            Accept FAIL             ---	            No need to close – Was not opened
---     	    Accept OK	            CREATED	
CREATED	        Receive Handshake FAIL	---	            Close socket – No Close message
CREATED	        Receive Handshake OK	HANDSHAKE	
HANDSHAKE	    Send Handshake FAIL	    ---	            Close socket – No Close message
HANDSHAKE	    Send Handshake OK	    OPEN	
OPEN	        Receive Data OK	        OPEN	
OPEN	        Send Data OK	        OPEN	
OPEN	        Receive Data FAIL	    CLOSING STS	    Server Trigger Start
OPEN	        Send Data FAIL	        CLOSING STS	    Server Trigger Start
OPEN	        Receive Close Request	CLOSING CTS	    Client Trigger Start
CLOSING CTS	    Send Close FAIL	        ---	            Close socket – No (further) Close message
CLOSING CTS	    Send Close OK	        ---	            Close socket
CLOSING STS	    Send Close FAIL	        ---	            Close socket – No (further) Close message
CLOSING STS	    Send Close OK	        CLOSING STW	    Server Trigger Wait
CLOSING STW	    Receive Close OK	    ---	            Close socket
CLOSING STW	    Receive Close FAIL	    ---	            Close socket




EPOLL, ASYNC AND MULTI THREADING

The epoll mechanism in Linux is designed to handle multiple I/O events asynchronously. 
It allows you to register multiple file descriptors (like sockets) and will notify you when I/O is ready on any of them, 
without blocking your program in the meantime.

When you call epoll_wait, it will return any events that are ready. 
If no events are ready, it will wait until at least one is ready. 
But while it's waiting, your program is free to do other things. 
This is the essence of asynchronous I/O: your program doesn't block waiting for I/O, but instead can handle I/O whenever it's ready.

However, it's important to note that while epoll itself is asynchronous, 
the I/O operations you perform when an event is ready (like read or write on a socket) are typically blocking operations. 
To perform these operations asynchronously as well, you would need to use non-blocking I/O (by setting the O_NONBLOCK flag on your sockets), 
or offload these operations to another thread or process.

Epoll with Thread Pools:

Advantages:
Concurrency: By using multiple threads, the server can take advantage of multiple cores and handle more connections simultaneously.
Simplicity: Compared to asynchronous I/O, multi-threaded programming can be simpler to understand because each thread can be written in a straightforward, 
sequential manner.

Disadvantages:
Overhead: Creating and managing threads has overhead. If not managed properly, too many threads can lead to context-switching overhead and memory consumption.
Synchronization: Shared resources must be protected with locks, which can lead to contention and potential deadlocks


Using epoll with non-blocking I/O (O_NONBLOCK) and thread pools can be a very 
effective way to build a high-performance and scalable WebSocket server in C++ on Linux.

This approach allows you to handle multiple connections simultaneously (thanks to epoll and non-blocking I/O) 
and to take advantage of multiple cores (thanks to thread pools).

However, it's important to note that this approach also adds complexity to your program. You'll need to carefully 
manage your threads and handle the asynchronous nature of non-blocking I/O. You'll also need to handle potential 
race conditions and ensure that shared resources are properly synchronized.
